---
title: "TypeScript 유틸리티 타입 5선"
emoji: "🧠"
category: "it"
tags: ["TypeScript", "타입시스템"]
difficulty: 2
pubDate: "2026-02-15"
storyType: "firstPerson"
---

<!-- step:hook -->

코드 리뷰에서 동료가 `Partial<User>`를 쓴 걸 보고 멍했던 기억, 있으신가요? 저는 1년 차 때 타입을 일일이 다시 선언하다가 "이거 자동화 안 돼?"라고 외쳤습니다. 알고 보니 TypeScript가 **5가지 마법 도구**를 이미 준비해뒀더군요.

<!-- step:story -->

첫 프로젝트에서 유저 정보 업데이트 API를 만들 때였습니다. `User` 타입은 10개 필드가 있는데, PATCH 요청은 일부만 받아야 했죠. 그래서 `UserUpdate` 타입을 똑같이 복사한 뒤 모든 필드에 `?`를 붙였습니다. 20줄이 넘는 중복 코드였죠.

며칠 뒤 시니어가 PR에 한 줄 코멘트를 남겼습니다. "그냥 `Partial<User>` 쓰면 됩니다." 검색해보니 모든 필드를 자동으로 optional로 만들어주는 내장 타입이었습니다. 제가 20줄 짜던 걸 **5글자로 해결**한 거죠.

그날부터 공식 문서를 뒤지며 유틸리티 타입을 파헤쳤습니다. `Pick`으로 필요한 필드만 골라내고, `Omit`으로 민감 정보를 제외했죠. `Record`로 딕셔너리를 타입 안전하게 만들고, `ReturnType`으로 함수 리턴값을 추론했습니다.

한 달 뒤 타입 정의 코드가 절반으로 줄었고, 타입 에러는 배포 전에 전부 잡혔습니다.

<!-- step:reveal -->

**TypeScript 필수 유틸리티 타입 5선:**

1. **`Partial<T>`** — 모든 프로퍼티를 선택적(optional)으로 변경. 업데이트 함수에서 필수!
2. **`Pick<T, K>`** — 특정 프로퍼티만 선택해서 새로운 타입 생성. 최소 인터페이스 설계에 유용
3. **`Omit<T, K>`** — 특정 프로퍼티를 제외한 타입 생성. `Pick`의 반대 개념
4. **`Record<K, V>`** — 키-값 쌍으로 객체 타입 정의. 딕셔너리/맵 구조에 최적
5. **`ReturnType<T>`** — 함수의 리턴 타입 추출. 타입 추론이 필요할 때 강력

**보너스 팁**: `Readonly<T>`로 불변 객체를 만들면 실수로 수정하는 버그를 방지할 수 있습니다.

<!-- step:action -->

**오늘부터 실천할 것**: 타입을 복사-붙여넣기하려는 순간, 유틸리티 타입으로 해결할 수 있는지 먼저 떠올리세요. `Partial`, `Pick`, `Omit` 3개만 익혀도 타입 정의 코드를 **50% 이상 줄일 수 있습니다**. 제 경험이 증명합니다!

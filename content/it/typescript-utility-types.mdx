---
title: "TypeScript 유틸리티 타입 5선"
emoji: "🧠"
category: "it"
tags: ["TypeScript", "타입시스템"]
difficulty: 2
pubDate: "2026-02-15"
storyType: "realStory"
---

<!-- step:hook -->

레시피 앱을 만든다고 상상해보세요. "필수 재료" 목록이 있는데, 어떤 요리는 선택 재료도 받아야 합니다. 똑같은 재료 목록을 복사해서 전부 "선택"으로 바꾸시겠어요? TypeScript는 **마법 도구 5개**로 이 수고를 덜어줍니다.

<!-- step:story -->

커피숍 주문 시스템을 만들 때였습니다. `Order` 타입에는 음료, 크기, 온도, 샷 추가, 휘핑크림 같은 **10개 필드**가 있었죠.

그런데 "주문 수정" 기능을 만들려니 문제가 생겼습니다. 고객이 **일부만** 바꿀 수 있어야 했거든요. 크기만 바꾸거나, 온도만 바꾸거나.

그래서 `OrderUpdate` 타입을 만들었습니다. `Order`를 복사해서 모든 필드에 `?`를 붙였죠. 20줄짜리 중복 코드가 탄생했습니다.

```typescript
// 이렇게 하면 안 됩니다
type OrderUpdate = {
  drink?: string;
  size?: string;
  temperature?: string;
  // ... 10줄 더
}
```

시니어가 한 줄로 바꿔버렸습니다.

```typescript
type OrderUpdate = Partial<Order>; // 끝!
```

**`Partial`은 요리 레시피에서 모든 재료를 "선택"으로 바꾸는 마법**이었습니다.

<!-- step:detail -->

유틸리티 타입은 타입을 변형하는 **도구 상자**입니다. 레고 블록을 조립하듯이, 기존 타입을 골라내거나, 합치거나, 변형할 수 있죠.

실제 예시를 더 볼까요?

**`Pick` — 필요한 것만 골라내기**

회원가입 폼에서는 이메일과 비밀번호만 필요합니다. 10개 필드 중 2개만 쓰려고 새 타입을 만들 필요 없습니다.

```typescript
type SignupForm = Pick<User, 'email' | 'password'>; // 딱 2개만
```

마치 뷔페에서 **먹고 싶은 것만 접시에 담는 것**과 같습니다.

**`Record` — 딕셔너리 만들기**

국가별 언어 설정을 저장한다면?

```typescript
type LanguageMap = Record<'ko' | 'en' | 'ja', string>;
// { ko: "한국어", en: "English", ja: "日本語" }
```

**키-값 쌍을 타입 안전하게** 만드는 사전입니다.

<!-- step:reveal -->

**TypeScript 필수 유틸리티 타입 5선:**

1. **`Partial<T>`** — 모든 필드를 선택(optional)으로 변환
   - 🎯 업데이트 함수, PATCH API 요청에 필수

2. **`Pick<T, K>`** — 특정 필드만 골라서 새 타입 생성
   - 🎯 최소한의 데이터만 주고받을 때 (폼, API 응답)

3. **`Omit<T, K>`** — 특정 필드를 제외한 타입 생성
   - 🎯 민감 정보 제거 (`password` 빼고 전송)

4. **`Record<K, V>`** — 키-값 쌍 객체 타입 정의
   - 🎯 설정 객체, 딕셔너리 구조

5. **`ReturnType<T>`** — 함수의 리턴 타입 추출
   - 🎯 타입 추론이 필요한 고급 패턴

**보너스**: `Readonly<T>`로 불변 객체를 만들면 "실수로 수정" 버그가 사라집니다.

<!-- step:action -->

**오늘부터 실천**: 타입을 복사-붙여넣기하려는 순간, **"유틸리티 타입으로 해결할 수 있나?"** 먼저 떠올리세요. `Partial`, `Pick`, `Omit` 3개만 익혀도 타입 정의 코드를 절반으로 줄일 수 있습니다!

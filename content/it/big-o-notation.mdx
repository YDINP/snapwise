---
title: "Big O 표기법 핵심 정리"
emoji: "📐"
category: "it"
tags: ["알고리즘", "자료구조"]
difficulty: 2
style: "gradient"
pubDate: "2026-02-15"
storyType: "fable"
---

<!-- step:hook -->

도서관에서 책을 찾는다고 상상해보세요. **처음부터 끝까지 뒤지면** 1시간, **목차를 보면** 5분, **사서에게 물으면** 1분. 알고리즘 선택이 바로 이 차이를 만듭니다.

<!-- step:story -->

옛날 마을 도서관에는 1만 권의 책이 있었습니다.

**게으른 사서**는 항상 첫 번째 책부터 순서대로 찾았습니다. 평균 5,000권을 뒤져야 원하는 책을 찾았죠. 손님들은 1시간씩 기다렸습니다. 이게 **O(n) 선형 탐색**입니다.

**영리한 사서**는 책을 알파벳 순으로 정렬했습니다. 중간 책을 펴서 "찾는 책이 앞쪽인가 뒤쪽인가?"를 확인하고, 반씩 제거했죠. 10번만 반복하면 1만 권 중에서도 찾았습니다. 손님들은 5분만 기다렸습니다. 이게 **O(log n) 이진 탐색**입니다.

**천재 사서**는 책 제목을 해시 테이블로 만들었습니다. 손님이 제목을 말하면 즉시 위치를 알려줬죠. 기다림 없이 1분 만에 해결. 이게 **O(1) 상수 시간**입니다.

**최악의 사서**는 모든 책 조합을 비교했습니다. 2권만 비교해도 1억 번 연산. 손님들은 평생을 기다렸습니다. 이게 **O(n²) 제곱 시간**입니다.

당신의 코드는 어떤 사서인가요?

<!-- step:reveal -->

**시간 복잡도 빠름 → 느림 순서:**

1. **O(1) — 상수 시간**
   - 배열 인덱스 접근, 해시 테이블 검색
   - 예: `arr[5]` → 즉시 값 반환

2. **O(log n) — 로그 시간**
   - 이진 탐색, 균형 트리 탐색
   - 예: 1,000개 데이터에서 10번만 비교

3. **O(n) — 선형 시간**
   - 배열 순회, 단순 탐색
   - 예: `for` 문으로 전체 탐색

4. **O(n log n) — 선형 로그**
   - 병합 정렬, 퀵 정렬
   - 대부분의 효율적인 정렬 알고리즘

5. **O(n²) — 제곱 시간**
   - 중첩 반복문, 버블 정렬
   - 예: 이중 `for` 문

6. **O(2ⁿ) — 지수 시간**
   - 피보나치 재귀 (메모이제이션 없이)
   - 예: 매 단계마다 2배씩 증가

**실무 팁**: n = 1,000일 때 O(n²)는 **100만 번** 연산, O(n log n)은 **1만 번** 연산입니다.

<!-- step:action -->

**오늘부터 실천**: 반복문을 쓰기 전에 "이 작업을 O(1)이나 O(log n)으로 할 수 있을까?"를 먼저 고민하세요. 해시 테이블을 쓰거나 정렬된 데이터에 이진 탐색을 적용하면 **성능이 100배 이상 차이날 수 있습니다**. 알고리즘 선택이 성능을 좌우합니다!

---
title: "SOLID 원칙 30초 요약"
emoji: "🏗️"
category: "it"
tags: ["설계원칙", "OOP"]
difficulty: 2
style: "gradient"
pubDate: "2026-02-15"
storyType: "realStory"
---

<!-- step:hook -->

2000년대 초, 소프트웨어 개발자들은 같은 문제로 고통받았습니다. 코드를 수정하면 **예상치 못한 곳에서 버그가 터졌죠**. 마치 젠가처럼, 한 블록을 빼면 전체가 무너졌습니다. 그때 로버트 마틴(Uncle Bob)이 나타나 **5가지 원칙**을 제시했습니다.

<!-- step:story -->

2002년, 로버트 마틴은 수십 년간 쌓인 객체지향 설계 경험을 정리했습니다. 그는 "왜 어떤 코드는 10년이 지나도 유지보수가 쉽고, 어떤 코드는 1년 만에 레거시가 되는가?"를 연구했죠.

그가 발견한 핵심은 **책임의 분리**였습니다. 한 클래스가 너무 많은 일을 하면, 수정할 때 연쇄 폭발이 일어난다는 것. 반대로 책임을 잘게 나누면, 한 부분을 수정해도 다른 부분은 안전했습니다.

하지만 무작정 나누기만 하면 복잡도가 폭증했습니다. 그래서 그는 **5가지 균형 원칙**을 만들었습니다. 단일 책임으로 나누되, 확장에는 열려있고, 상속은 안전하게, 인터페이스는 작게, 의존은 추상화로.

이 원칙들은 **SOLID**라는 이름으로 전 세계 개발자들의 바이블이 됐습니다. 마이크로소프트, 구글, 아마존의 코드베이스에도 녹아들었죠.

<!-- step:reveal -->

**SOLID 5대 원칙:**

**S — Single Responsibility (단일 책임)**
- 클래스는 **하나의 이유**로만 변경되어야 합니다
- 예: `User` 클래스는 유저 정보만, 이메일 발송은 `EmailService`로

**O — Open/Closed (개방-폐쇄)**
- 확장에는 **열려**있고, 수정에는 **닫혀**있어야 합니다
- 예: 새 결제 방식을 추가할 때 기존 코드를 수정하지 않음

**L — Liskov Substitution (리스코프 치환)**
- 자식 클래스는 **부모 클래스를 대체**할 수 있어야 합니다
- 예: `Square`가 `Rectangle`을 상속하면 안 됨 (정사각형은 직사각형이지만, 행동이 다름)

**I — Interface Segregation (인터페이스 분리)**
- 사용하지 않는 인터페이스에 **의존하지 않아야** 합니다
- 예: `Printer` 인터페이스에 `fax()` 메서드를 넣지 말 것

**D — Dependency Inversion (의존 역전)**
- 구체적인 것이 아닌 **추상화에 의존**해야 합니다
- 예: `Database` 클래스가 아닌 `IDatabase` 인터페이스에 의존

<!-- step:action -->

**오늘부터 실천**: 클래스를 만들 때 "이 클래스가 변경될 이유가 몇 개나 될까?"를 먼저 물어보세요. **2개 이상이면 분리**하는 습관을 들이면, 6개월 뒤 코드 리뷰에서 "이거 누가 짠 거야?" 소리를 들을 겁니다. 좋은 의미로요!

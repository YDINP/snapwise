---
title: "Promise vs async/await 완벽 정리"
emoji: "⚡"
category: "it"
tags: ["JavaScript", "비동기"]
difficulty: 2
style: "gradient"
pubDate: "2026-02-15"
storyType: "fable"
---

<!-- step:hook -->

커피를 주문하고 카운터에서 기다리는 대신, **진동벨을 받고 자리에 앉아 기다리면** 어떨까요? 비동기 프로그래밍이 바로 이겁니다. JavaScript는 두 가지 진동벨을 제공합니다. `Promise`와 `async/await`.

<!-- step:story -->

옛날 카페에서는 주문하면 **카운터 앞에서 계속 기다려야** 했습니다. 다른 손님들도 줄을 서서 기다렸죠. 이게 바로 **콜백 지옥**입니다.

어느 날, 카페 주인이 **진동벨 시스템**을 도입했습니다. 주문하면 벨을 받고, 준비되면 울립니다. 손님들은 자리에 앉아서 다른 일을 할 수 있었죠. 이게 바로 **Promise**입니다.

```javascript
// Promise 방식 (진동벨 받기)
orderCoffee().then(coffee => drink(coffee)).then(() => console.log("만족!"));
```

하지만 벨을 여러 개 받으면 복잡해집니다. 커피, 샌드위치, 디저트를 따로 주문하면 **3개 벨**을 들고 있어야 하죠.

그래서 카페가 **주문표 시스템**을 만들었습니다. 주문표에 적힌 순서대로 자동으로 가져다줍니다. 손님은 그냥 기다리면 됩니다. 이게 바로 **async/await**입니다.

```javascript
// async/await 방식 (주문표)
const coffee = await orderCoffee();
const sandwich = await orderSandwich();
console.log("둘 다 왔다!");
```

이제 카페는 붐비지 않고, 손님들도 편하게 기다립니다.

<!-- step:reveal -->

**Promise vs async/await 핵심 차이:**

**Promise 방식**
- `.then()` 체인으로 연결
- 콜백 지옥을 해결했지만, 여전히 중첩될 수 있음
- 에러 처리는 `.catch()`

**async/await 방식**
- **동기 코드처럼 읽히지만** 비동기로 실행
- `try/catch`로 깔끔한 에러 처리
- 코드가 직관적이고 읽기 쉬움

**병렬 실행이 필요하면?**
- `await Promise.all([api1(), api2()])` 패턴 사용
- 두 API를 동시에 호출하고, 둘 다 완료될 때까지 기다림

<!-- step:action -->

**오늘부터 실천**: 새로운 비동기 코드는 무조건 `async/await`로 작성하세요. 기존 Promise 코드도 리팩토링하면 **가독성이 2배 올라갑니다**. 단, 여러 API를 병렬로 호출할 땐 `Promise.all()`을 잊지 마세요!
